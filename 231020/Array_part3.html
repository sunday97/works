<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Array part3</title>
  </head>
  <body></body>
  <script>
    // 1. forEach() 메소드(Method, 함수)
    // 해당 배열의 모든 요소에 대하여 반복적으로 명시된 함수를 실행한다.
    document.write("<h4>1. forEach() </h4>");
    const arr = [1, true, "Javascript"];
    function printArr(val, ind, arr) {
      document.write(`arr[${ind}] = ${val} <br>`);
    }
    // 함수 안에 있는 또 다른 함수 = 콜백함수 ex)아래의 ()안의 printArr
    // forEach ex) arr.forEach(callback function); ()안에 익명함수도 ㅇㅋ 왜냐? 한 번만 사용하는 임시함수니까.
    arr.forEach(printArr);
    console.log(printArr); // 함수 자체(식) 이 출력
    console.log(printArr()); // 호출한다. 리턴 없다. 함수 자체를 의미 x. 화면에 arr[undefined] = undefined나오는 이유는 함수 안에 doc.wit가 있잖아.

    // window + . : 윈도우 내장 이모지

    document.write("<hr>");

    // 2. map() 메소드 ✨
    // 해당 배열의 모든 요소에 대하여 반복적으로 명시된 콜백 함수를 실행한 후, 그 실행 결과를 새로운 배열에 담아 반환한다.
    document.write("<h4>1. map() </h4>");

    const arr2 = [3, 4, 5, 6];
    const tempArr = [];
    // for (let i = 0; i < arr.length; i++) {
    //   tempArr.push(arr[i] * 3);
    // }

    // let modifiedArr = arr2.map(function (element, index, array) {
    //   return element * 3;
    // });
    let modifiedArr = arr2.map((v) => v * 3); // 화살표 함수에는 return 속성을 함유하고 있기에 생략가능.

    document.write(`arr2 : [${arr2}] <br>`);
    document.write(`arr2의 원소에 *3 : [${modifiedArr}] <br>`);

    document.write(`<br>`);

    console.log(modifiedArr);

    // 위 map() 내장함수를 풀어쓰면 간략하게나마 이런 느낌일껄?
    /**
     function map(arr2) {
         let tempArr = [];
         function temp(element) {
             return element * 3;
            }
            for (let i = 0; i < arr2.length; i++) {
                tempArr.push(temp(arr[i]));
            }
        }
        */

    let users = [
      { firstName: "Beckham", lastName: "David" },
      { firstName: "Elton", lastName: "John" },
      { firstName: "Grande", lastName: "Ariana" },
    ];

    // let names = users.map(function (val) {
    //   document.write(`${val.lastName} ${val.firstName} <br>`);
    // });

    // console.log(
    //   users.map(function (v) {
    //     v.lastName+v.firstName;
    //   })
    // );
    // let pushName = [];
    // pushName.push(
    //   users.map(function (val) {
    //     val.lastName + val.firstName;
    //   })
    // );
    // console.log(pushName);

    let nameArr = users.map(function (v) {
      return ` ${v.lastName} ${v.firstName} `; //return 값을 반환
    });
    // let nameArr = users.map((v) => `${v.lastName} ${v.firstName}`);

    document.write(`users : [${users}] <br>`);
    document.write(`nameArr : [${nameArr}] <br>`);

    document.write(`<br>`);

    const numberArr = [1, 2, 3, 4, 5, 6, 7, 8, 9];
    function multiplyTow(number) {
      return number * 2;
    }
    const newNumberArr = numberArr.map(multiplyTow);
    document.write(`numberArr : [${numberArr}] <br>`);
    document.write(`newNumberArr : [${newNumberArr}]<br>`);

    document.write(`<br>`);

    const numberArr2 = [
      [1, 2, 3],
      [4, 5, 6],
      [7, 8, 9],
    ];
    // let newNumberArr2 = numberArr2.map(function (v) {
    //   return ` [${v.map(multiplyTow)}]`;
    // });

    const newNumberArr2 = numberArr2.map((el) =>
      el.map((number) => number * 2)
    );

    document.write(`[ ${newNumberArr2} ]`);

    document.write("<hr>");

    // 1.filter() 함수
    // 배열의 모든 요소에 대하여 반복적으로 명시된 콜백 함수를 실행한 후, 그 결과값이 ture인 요소들만을 새로운 배열로 반환한다.
    document.write("<h4>3. filrer() 함수 </h4>");
    const numberArr3 = [1, 2, 3, 4, 5];
    let tempNewNumber3 = [];
    let result = [];
    for (let i = 0; i < numberArr3.length; i++) {
      if (numberArr3[i] > 3) {
        tempNewNumber3.push(numberArr3[i]);
      }
    }
    // tempNewNumber3 = numberArr3.map((el) => {
    //   if (el > 3) {
    //     tempNewNumber3.push(numberArr3[i]);
    //   }
    // });

    console.log(tempNewNumber3);
    document.write(`numberArr3 : [${numberArr3}] <br>`);
    document.write(`tempNewNumber3 : [${tempNewNumber3}] <br>`);

    // result = numberArr3.map(function (el) {
    //   return el > 3;
    // });

    // result = numberArr3.filter((el, index, array) => el > 3);
    result = numberArr3.filter((el) => el > 3);

    document.write(`result : [${result}]<br>`);

    const guys = [
      { name: "민수", money: 500000 },
      { name: "강민", money: 600000 },
      { name: "수지", money: 800000 },
      { name: "의령", money: 400000 },
    ];

    let richGuys = [];
    richGuys = guys.filter((el) => el.money > 500000);
    console.log(richGuys);
    let richGuysName = richGuys.map(function (el) {
      return el.name;
    });

    // 한번에 쓰는 경우
    const richName = guys
      .filter((el) => el.money > 500000)
      .map((el) => el.name);

    console.log(richGuysName);
    document.write(richGuysName + "<br>");
    document.write(richName);

    // 조건이 여러개인 경우
    const twoConditionGuy = guys.filter(
      (el) => el.money > 500000 && el.name == "수지"
    );
    // const twoConditionGuy = guys.filter((el) => {
    //   if (el.money > 500000) {
    //     if (el.name == "수지") {
    //       return true;
    //     }
    //   }
    //   return false;
    // });
    // if문을 사용할 때에는 filter함수가 ture false 값을 측정해서 값은 뱉는것이기 때문에 if로 reture값도 ture&false값이 되어야 한다.
    console.log(twoConditionGuy);

    // document.write(`50만원 이상을 가진 사람들은 ${richGuys}들 입니다.`);
  </script>
</html>
